#include <GL/gl.h>
#include <GL/glext.h>

#include <SDL/SDL.h>
#include <SDL/SDL_gfxPrimitives.h>
#include <SDL/SDL_image.h>

#include <iostream>
#include <sstream>

#include "graphics.h"
// #include "core.h"

using namespace std;

namespace gp2d
{

// The one and only instance of the window.
// Firstly initialized to NULL, or else we get some errors :)
	GP2DWindow* GP2DWindow::m_instance = NULL;

	GP2DWindow* GP2DWindow::getInstance()
	{
		if ( m_instance == NULL )   // instance not already created?
		{
			// then create it!
			m_instance = new GP2DWindow();
			// Set the default video API to SDL
			m_instance->setRenderMode ( GP2DWindow::GP2D_OPENGL );
		}
		// and return it.
		return m_instance;
	}

	/**
	 * Create a window instance. Done by using GP2DWindow::getInstance().
	 */
	GP2DWindow::GP2DWindow()
	{
		m_fullScreen = false; // initially, fullscreen mode is OFF.
		m_videoAPI = GP2DWindow::GP2D_OPENGL; // defaults to opengl rendering, rox more.
	}

	/**
	 * Destructor. Deletes some resources occupied by this object.
	 */
	GP2DWindow::~GP2DWindow()
	{
		SDL_FreeSurface ( m_surfaceScreen );
	}

	/**
	 * Toggles fullscreen mode on, or off. Internally, a bool will be set stating
	 * whether the screen is currently in fullscreen mode.
	 */
	void GP2DWindow::toggleFullScreen() throw ( GP2DException )
	{
		m_fullScreen = !m_fullScreen; // flip the fullscreen boolean indication
		if ( m_surfaceScreen != NULL )
		{
			SDL_WM_ToggleFullScreen ( m_surfaceScreen );
		}
		else
		{
			throw GP2DException ( "Fullscreen toggle failed" );
		}
	}

	/**
	 * Returns the height of the window.
	 */
	int GP2DWindow::getHeight() const
	{
		return m_screenHeight;
	}

	/**
	 * Returns the width of the window.
	 */
	int GP2DWindow::getWidth() const
	{
		return m_screenWidth;
	}

	/**
	 * Returns the screen surface (used for the SDL rendering mode and the blitting routine)
	 */
	SDL_Surface* GP2DWindow::getSurface()
	{
		return m_surfaceScreen;
	}

	/**
	 * Changes the background color to clear the background with.
	 */
	void GP2DWindow::setBackgroundColor ( int r, int g, int b )
	{
		m_backgroundColorArray[0]=r;
		m_backgroundColorArray[1]=g;
		m_backgroundColorArray[2]=b;
	}

	/**
	 * Input grabbing of events.
	 */
	void GP2DWindow::setInputGrabEnabled ( bool enabled )
	{
		if ( enabled )
		{
			SDL_WM_GrabInput ( SDL_GRAB_ON );
		}
		else
		{
			SDL_WM_GrabInput ( SDL_GRAB_OFF );
		}
	}

	/**
	 * Graphic defaults. Can be called at any time.
	 */
	void GP2DWindow::setGraphicsDefaults()
	{
		if ( m_videoAPI == GP2D_SDL )
		{
		}
#ifndef NOGL
		else
		{
			glShadeModel ( GL_SMOOTH ); // smooth shading.
			glClearColor ( 0.0f, 0.0f, 0.0f, 0.0f ); // black is the default clearing color.

			glEnable ( GL_LINE_SMOOTH ); // smooth lining (anti aliasing?)
			glEnable ( GL_POINT_SMOOTH ); // point smoothing
			glEnable ( GL_POLYGON_SMOOTH ); // polygon smoothing
			glEnable ( GL_TEXTURE_2D ); // enable 2D texturisation.
			glEnable ( GL_BLEND ); // enable (alpha) blending.
		}
#endif
	}

	/**
	 * Sets the window title.
	 */
	void GP2DWindow::setWindowTitle ( string title )
	{
		SDL_WM_SetCaption ( title.c_str(), NULL );
	}

	/**
	 * Sets the no-frame flag.
	 */
	void GP2DWindow::setFlagNoFrame()
	{
		m_videoFlags |= SDL_NOFRAME;
	}

	/**
	 * Sets resizable flag.
	 */
	void GP2DWindow::setFlagResizable()
	{
		m_videoFlags |= SDL_RESIZABLE;
	}

	/**
	 * Clear the screen.
	 */
	void GP2DWindow::clearScreen()
	{
		GP2DWindow* window = GP2DWindow::getInstance();
		if ( window->getRenderMode() == GP2DWindow::GP2D_SDL )
		{
			m_backgroundColor = SDL_MapRGB ( m_surfaceBackground->format, m_backgroundColorArray[0], m_backgroundColorArray[1] ,m_backgroundColorArray[2] );
			SDL_FillRect ( m_surfaceBackground, 0, m_backgroundColor );
			SDL_BlitSurface ( m_surfaceBackground, NULL, window->getSurface(), NULL );
		}
#ifndef NOGL
		else
		{
            glClearColor( (float)m_backgroundColorArray[0]/255, (float)m_backgroundColorArray[1]/255 ,(float)m_backgroundColorArray[2]/255, 1.0f );
			glClear ( GL_COLOR_BUFFER_BIT );
		}
#endif
	}

	/**
	 * Synchronize buffers.
	 */
	void GP2DWindow::sync()
	{
		GP2DWindow* window = GP2DWindow::getInstance();
		if ( window->getRenderMode() == GP2DWindow::GP2D_SDL )
		{
			SDL_UpdateRect ( window->getSurface(),0,0,0,0 );
		}
#ifndef NOGL
		else
		{
			glFlush(); // for single buffer only
			SDL_GL_SwapBuffers(); // for double buffer only.
		}
#endif
	}

	/**
	 * Check the status of the window if it is opened or not.
	 */
	bool GP2DWindow::isCreated()
	{
		return m_surfaceScreen != NULL ? true : false;
	}

	/**
	 * Does the actual work. Will throw an exception if GP2DEngine::initVideo() or
	 * GP2DEngine::initAll() was not called first.
	 */
	void GP2DWindow::createWindow ( int width, int height, int bpp ) throw ( GP2DException )
	{
		const SDL_VideoInfo* m_videoInfo = SDL_GetVideoInfo();

		if ( m_videoInfo == NULL )
		{
			throw GP2DException ( "Unable to create a window: video was not initialized." );
		}

		if ( m_videoAPI == GP2D_SDL )
		{
			m_videoFlags = SDL_DOUBLEBUF | SDL_HWPALETTE; // set default flags for SDL only
		}
#ifndef NOGL
		else
		{
			m_videoFlags = SDL_OPENGL | SDL_HWPALETTE; // set default flags for
			// OpenGL
		}
#endif

		// check to see if a surface can be stored in mem:
		if ( m_videoInfo->hw_available )
		{
			m_videoFlags |= SDL_HWSURFACE;
		}
		else
		{
			m_videoFlags |= SDL_SWSURFACE;
		}

		// check to see if hardware blits can be done
		if ( m_videoInfo->blit_hw )
		{
			m_videoFlags |= SDL_HWACCEL;
		}

		if ( m_videoAPI == GP2D_SDL )
		{
		}
#ifndef NOGL
		else
		{
			// Sets up OpenGL double buffering
			SDL_GL_SetAttribute ( SDL_GL_DOUBLEBUFFER, true );
		}
#endif
		// check whether the video mode is supported.
		int modeOK = SDL_VideoModeOK ( width, height, bpp, m_videoFlags );

		if ( modeOK != 0 )
		{
			// this next function actually OPENS the window too!
			m_surfaceScreen = SDL_SetVideoMode ( width, height, bpp, m_videoFlags );
			m_screenWidth = width;
			m_screenHeight = height;
			m_screenDepth = bpp;

			if ( m_videoAPI == GP2D_SDL )
			{
				setBackgroundColor ( 0,0,0 );
				m_surfaceBackground = SDL_CreateRGBSurface ( SDL_HWSURFACE, m_screenWidth, m_screenHeight, m_screenDepth, 0, 0, 0, 0 );
			}

		}
		else
		{
			// video mode here is not supported. Throw up an exception so we know
			// it is not supported.
			stringstream s;
			s << "Video mode " << width << "x" << height << "x" << bpp
			<< " is not supported. Bitmask video flags: " << m_videoFlags;
			throw GP2DException ( s.str() );
		}

	}

	/*
	 * Changes the rendering API to use.
	 */
	void GP2DWindow::setRenderMode ( const GP2DRenderMode mode )
	{
		m_videoAPI = mode;
#ifdef NOGL
if(mode == GP2DWindow::GP2D_OPENGL) clog<<"Warning: OpenGL not supported. Using SDL mode."<<endl;
m_videoAPI = GP2DWindow::GP2D_SDL;
#endif
	}

	/*
	 * Returns the current rendering API.
	 */
	GP2DWindow::GP2DRenderMode GP2DWindow::getRenderMode() const
	{
		return m_videoAPI;
	}

	/*
	 * Creates a new camera by adding a GP2DCamera class into a vector, with default
	 * range and update as soon as it is created.
	 *
	 * TODO: Error checking & exception throw.
	 */
	void GP2DWindow::createNewCamera()
	{
		m_camera.push_back ( GP2DCamera ( getHeight() /2 ) );
		m_currentCamera = m_camera.size()-1;
		m_camera[m_currentCamera].updateCamera();
	}

	/*
	 * Returns a pointer to the current camera to be used with various engine
	 * operations.
	 *
	 * TODO: Error checking & exception throw.
	 */
	GP2DCamera* GP2DWindow::getCamera() throw ( GP2DException )
	{
		if ( m_camera.size() <=0 ) throw GP2DException ( "No camera available." );
		return &m_camera[m_currentCamera];
	}

	/*
	 * Returns a pointer to a specific camera to be used with various engine
	 * operations.
	 *
	 * TODO: Error checking & exception throw.
	 */
	GP2DCamera* GP2DWindow::getCamera ( int num )
	{
		return &m_camera[num];
	}

	/*
	 * Sets the current camera in relation to the GP2DCamera vector.
	 *
	 * TODO: Error checking & exception throw.
	 */
	void GP2DWindow::setCamera ( int num )
	{
		m_currentCamera = num;
	}

//==============================================================================

	/**
	 * Create!
	 */
	GP2DCamera::GP2DCamera ( int range )
	{
		initializeCamera ( range );
	}

	/**
	 * Destroy!
	 */
	GP2DCamera::~GP2DCamera()
	{
	}

	/**
	 * Initializes the camera.
	 */
	void GP2DCamera::initializeCamera ( int range ) throw ( GP2DException )
	{
		GP2DWindow* window = GP2DWindow::getInstance();
		if ( window->getRenderMode() == GP2DWindow::GP2D_SDL )
		{
			m_range = range;
			if ( !window->isCreated() )
			{
				// well, the window cannot be allocated. Be sure to notify the
				// programmer by throwing an exception.
				throw GP2DException ( "Window cannot be allocated." );
			}
			int height = window->getHeight();

			// no division by zeroes, plx!
			if ( height == 0 )
			{
				height = 1;
			}

		}
#ifndef NOGL
		else
		{

			m_range = range;


			if ( !window->isCreated() )
			{
				// well, the window cannot be allocated. Be sure to notify the
				// programmer by throwing an exception.
				throw GP2DException ( "Window cannot be allocated." );
			}

			int height = window->getHeight();
			int width = window->getWidth();

			// no division by zeroes, plx!
			if ( height == 0 )
			{
				height = 1;
			}

			// the aspect ratio of the 'window'
			GLfloat aspectRatio = ( GLfloat ) width / ( GLfloat ) height;

			glViewport ( 0, 0, ( GLsizei ) width, ( GLsizei ) height );

			// make sure to change the projection matrix.
			glMatrixMode ( GL_PROJECTION );
			glLoadIdentity();

			if ( width <= height )
			{
				glOrtho ( -range, range,
				          -range / aspectRatio, range / aspectRatio,
				          -range, range );
			}
			else
			{
				glOrtho ( -range * aspectRatio, range * aspectRatio,
				          -range, range,
				          -range, range );
			}

			// this translates the orthographic projection to the desired x and y.
			// don't know why exactly this works, but some website refer to it as 'working'.
			glTranslatef ( ( float ) getX(), ( float ) getY(), 0.0f );

			// change the modelview matrix, and load it.
			glMatrixMode ( GL_MODELVIEW );
			glLoadIdentity();

		}
#endif
	}

	/**
	 * Updates the camera view.
	 */
	void GP2DCamera::updateCamera()  throw ( GP2DException )
	{
		try
		{
			initializeCamera ( m_range );
		}
		catch ( GP2DException )
		{
			throw; // re-throw the exception.
		}
	}

	/**
	 * Set range.
	 */
	void GP2DCamera::setRange ( int range )
	{
		m_range = range;
	}

	/**
	 * Get range.
	 */
	int GP2DCamera::getRange() const
	{
		return m_range;
	}

	/**
	 * Sets x, y positions.
	 */
	void GP2DCamera::setPosition ( float x, float y )
	{
		m_posX = x;
		m_posY = y;
		updateCamera();
	}

	float GP2DCamera::getX() const
	{
		return m_posX;
	}

	float GP2DCamera::getY() const
	{
		return m_posY;
	}

//==============================================================================
   void   GP2DTexture::deleteTexture(){
      glDeleteTextures ( 1, &m_texID );
   }

	GP2DTexture::GP2DTexture () throw ( GP2DException )
	{
		GP2DWindow* window = GP2DWindow::getInstance();
        SDL_Surface* surf = SDL_CreateRGBSurface(SDL_HWSURFACE | SDL_SRCALPHA, 256, 256, window->getSurface()->format->BitsPerPixel, 0,0,0,0);
        if(!surf){
            throw GP2DException("Unable to create null surface",SDL_GetError());
        }
        m_surface = SDL_DisplayFormatAlpha ( surf );
        m_surface = surf;
		m_width = m_surface->w;
		m_height = m_surface->h;
    	m_pixels = m_surface->pixels;
    }

	GP2DTexture::GP2DTexture ( string file ) throw ( GP2DException )
	{
		GP2DWindow* window = GP2DWindow::getInstance();
		SDL_Surface* surf = IMG_Load ( file.c_str() );
		if ( surf != NULL )
		{
			if ( window->getRenderMode() == GP2DWindow::GP2D_SDL )
			{
				m_surface = SDL_DisplayFormatAlpha ( surf );

				m_width = m_surface->w;
				m_height = m_surface->h;
				m_pixels = m_surface->pixels;

				cout << "Texture loaded: " << file << ", "
				<< m_width  << "x" << m_height << endl;
			}
#ifndef NOGL
			else
			{
				m_surface = SDL_DisplayFormatAlpha ( surf );

				glGenTextures ( 1, &m_texID );
				glBindTexture ( GL_TEXTURE_2D, m_texID );
				glTexImage2D ( GL_TEXTURE_2D, 0, 4, m_surface->w, m_surface->h, 0, GL_BGRA, GL_UNSIGNED_BYTE, m_surface->pixels );
				glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
				glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );

				m_width = m_surface->w;
				m_height = m_surface->h;
				m_pixels = m_surface->pixels;

				clog << "Texture loaded (OGL): " << file << ", "
				<< m_width  << "x" << m_height << endl;

				// free the OLD surface, but do not free the alpha surface m_surface.
				SDL_FreeSurface ( surf );
			}
#endif
		}
		else
		{
			// Something bad happened. IMG_GetError probably returns some useful
			// information, so throw an exception indicating the problem. It might
			// for instance be a file which can not be found.
			throw GP2DException ( "Texture creation failed", IMG_GetError() );
		}

	}

	/**
	 * Deletes texture resources.
	 */
	GP2DTexture::~GP2DTexture()
	{
		GP2DWindow* window = GP2DWindow::getInstance();
		if ( window->getRenderMode() == GP2DWindow::GP2D_SDL )
		{
			SDL_FreeSurface ( m_surface );
		}
#ifndef NOGL
		else
		{
			SDL_FreeSurface ( m_surface );
			glDeleteTextures ( 1, &m_texID );
		}
#endif
	}



	unsigned int GP2DTexture::getId() const
	{
		return m_texID;
	}

	string GP2DTexture::getName() const
	{
		return m_texName;
	}

	float GP2DTexture::getWidth() const
	{
		return m_width;
	}

	float GP2DTexture::getHeight() const
	{
		return m_height;
	}

	void* GP2DTexture::getPixels()
	{
		return m_pixels;
	}

	void GP2DTexture::updateTexture()
	{
		GP2DWindow* window = GP2DWindow::getInstance();
		if ( window->getRenderMode() == GP2DWindow::GP2D_SDL )
		{
			//TODO
		}
#ifndef NOGL
		else {
//		clog << "Updating texture " << m_texID << endl;

		glGenTextures ( 1, &m_texID );
		glBindTexture ( GL_TEXTURE_2D, m_texID );
		glTexImage2D ( GL_TEXTURE_2D, 0, 4, m_surface->w, m_surface->h, 0, GL_BGRA, GL_UNSIGNED_BYTE, m_surface->pixels );
		glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
		glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
		}
#endif
	}

	/**
	 * Changes the texture's surface
	 */
    void GP2DTexture::setSurface(SDL_Surface* surf){
      // TODO: Should we really use DisplayFormatAlpha here?
      m_surface = SDL_DisplayFormatAlpha ( surf );
		m_width = m_surface->w;
		m_height = m_surface->h;
    	m_pixels = m_surface->pixels;
    }

	SDL_Surface* GP2DTexture::getSurface()
	{
		return m_surface;
	}

//==============================================================================

	GP2DRect::GP2DRect()
	{
	}

	GP2DRect::GP2DRect ( float x1, float y1, float x2, float y2 )
	{
		m_x1 = x1;
		m_x2 = x2;
		m_y1 = y1;
		m_y2 = y2;
	}

	GP2DRect::~GP2DRect()
	{
	}

//==============================================================================

	/**
	 * GP2DObject constructor.
	 */
	GP2DObject::GP2DObject()
	{
		m_x = 0.0f; // initialize the coordinates and all that to 0.0f.
		m_y = 0.0f;
		m_z = 0.0f;

		init();
	}

	GP2DObject::GP2DObject ( float x, float y )
	{
		m_x = x;
		m_y = y;
		m_z = 0.0f;

		init();
	}

	GP2DObject::GP2DObject ( float x, float y, float z )
	{
		m_x = x;
		m_y = y;
		m_z = z;

		init();
	}

	/**
	 * Destroy the object. Virtual destructor.
	 */
	GP2DObject::~GP2DObject()
	{
	}

	/**
	 * Do some initializing here of local class members.
	 */
	void GP2DObject::init()
	{
		m_height = 0.0f;
		m_width = 0.0f;
		m_x_velocity = 0.0f;
		m_y_velocity = 0.0f;
		m_angle_X = 0.0f;
		m_angle_Y = 0.0f;
		m_angle_Z = 0.0f;
	}

	/*
	 * Shitload of getters functions over here.
	 */

	float GP2DObject::getX() const
	{
		return m_x;
	}
	float GP2DObject::getY() const
	{
		return m_y;
	}
	float GP2DObject::getZ() const
	{
		return m_z;
	}
	float GP2DObject::getWidth() const
	{
		return m_width;
	}
	float GP2DObject::getHeight() const
	{
		return m_height;
	}
	float GP2DObject::getVelocity_X() const
	{
		return m_x_velocity;
	}
	float GP2DObject::getVelocity_Y() const
	{
		return m_y_velocity;
	}
	float GP2DObject::getRotation_X() const
	{
		return m_angle_X;
	}
	float GP2DObject::getRotation_Y() const
	{
		return m_angle_Y;
	}
	float GP2DObject::getRotation_Z() const
	{
		return m_angle_Z;
	}

	/*
	 * Shitload of setter methods right here.
	 */

	void GP2DObject::setX ( float x )
	{
		m_x = x;
	}
	void GP2DObject::setY ( float y )
	{
		m_y = y;
	}
	void GP2DObject::setZ ( float z )
	{
		m_z = z;
	}
	void GP2DObject::setPosition ( float x, float y )
	{
		m_x = x;
		m_y = y;
	}
	void GP2DObject::setWidth ( float w )
	{
		m_width = w;
	}
	void GP2DObject::setHeight ( float h )
	{
		m_height = h;
	}
	void GP2DObject::setVelocity_X ( float xvel )
	{
		m_x_velocity = xvel;
	}
	void GP2DObject::setVelocity_Y ( float yvel )
	{
		m_y_velocity = yvel;
	}
	void GP2DObject::setRotation_X ( float angle )
	{
		m_angle_X = angle;
	}
	void GP2DObject::setRotation_Y ( float angle )
	{
		m_angle_Y = angle;
	}
	void GP2DObject::setRotation_Z ( float angle )
	{
		m_angle_Z = angle;
	}
	void GP2DObject::addBoundingBox ( GP2DRect rect )
	{
		m_boundingBox = &rect;
	}

//==============================================================================

	GP2DSprite::GP2DSprite ( GP2DTexture* texture )
	{
		m_texture = texture;
		m_boundingBox = NULL;

		setWidth ( m_texture->getWidth() );
		setHeight ( m_texture->getHeight() );
	}

	GP2DSprite::~GP2DSprite()
	{

	}

	GP2DTexture* GP2DSprite::getTexture() const
	{
		return m_texture;
	}

	void GP2DSprite::draw()
	{

		GP2DWindow* window = GP2DWindow::getInstance();
		if ( window->getRenderMode() == GP2DWindow::GP2D_SDL )
		{

			setX ( getX() + getVelocity_X() );
			setY ( getY() + getVelocity_Y() );

			SDL_Rect dst;

            // WTF was this?
            /*
			window;
			window->getCamera();
			window->getCamera()->getX();
			getX() + window->getCamera()->getX();
            */

			dst.x = static_cast<Sint16> ( getX() + window->getCamera()->getX() ); // static casting, avoids warnings
			dst.y = static_cast<Sint16> ( -getY() + window->getCamera()->getY() ); // during compilation.
			dst.w = m_texture->getSurface()->w;
			dst.h = m_texture->getSurface()->h;

			SDL_BlitSurface ( m_texture->getSurface(), NULL, window->getSurface(), &dst );

			// for debugging purposes, indicate a border of the sprite.
			hlineRGBA ( window->getSurface(),dst.x,dst.x+dst.w,dst.y,255,255,255,255 );
			hlineRGBA ( window->getSurface(),dst.x,dst.x+dst.w,dst.y+dst.h,255,255,255,255 );
			vlineRGBA ( window->getSurface(),dst.x,dst.y,dst.y+dst.h,255,255,255,255 );
			vlineRGBA ( window->getSurface(),dst.x+dst.w,dst.y,dst.y+dst.h,255,255,255,255 );

		}
#ifndef NOGL
		else
		{
			// blending function, used to make alpha parts transparent or some sort.
			glEnable ( GL_BLEND );
			glBlendFunc ( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
			glBindTexture ( GL_TEXTURE_2D, m_texture->getId() ); // make sure we use the correct texture ID.

			// set the x and y positions based on the current velocity.
			setX ( getX() + getVelocity_X() );
			setY ( getY() - getVelocity_Y() );

			glMatrixMode ( GL_MODELVIEW_MATRIX );
			glLoadIdentity();
			glTranslatef ( getX()- ( window->getWidth() /2 ), getY() + ( window->getHeight() /2 ), getZ() );

			glRotatef ( getRotation_X(), 1.0f, 0.0f, 0.0f );
			glRotatef ( getRotation_Y(), 0.0f, 1.0f, 0.0f );
			glRotatef ( getRotation_Z(), 0.0f, 0.0f, 1.0f );

			glBegin ( GL_QUADS );
//            glColor4f(1.0f, 1.0f, 1.0f, 1.0f);  // Set the sprite's alpha (for PNG)

			/*
			 * The following texture coordinate mappings look retarded. This is
			 * because SDL flips the textures, vertically.
			 *
			 * Vertices:      Texture coordinates:
			 *   1--4               2--3
			 *   |  |               |  |
			 *   2--3               1--4
			 */
			glTexCoord2f ( 0.0f, 0.0f );
			glVertex3f ( 0, 0, getZ() );

			glTexCoord2f ( 0.0f, 1.0f );
			glVertex3f ( 0, 0 - getHeight(), getZ() );

			glTexCoord2f ( 1.0f, 1.0f );
			glVertex3f ( 0 + getWidth(), 0 - getHeight(), getZ() );

			glTexCoord2f ( 1.0f, 0.0f );
			glVertex3f ( 0 + getWidth(), 0, getZ() );

			glEnd();


			glDisable ( GL_BLEND );


			// for debugging purposes, indicate a border of the sprite.
			glLineWidth ( 0.125f );
			glBegin ( GL_LINES );
			// top left to right
			glColor3f ( 0.5f, 0.5f, 0.5f ); glVertex3f ( 0.0f, 0.0f, -5.0f );
			glColor3f ( 0.5f, 0.5f, 0.5f ); glVertex3f ( getWidth(), 0.0f, -5.0f );
			// top left to bottom left
			glColor3f ( 0.5f, 0.5f, 0.5f ); glVertex3f ( 0.0f, 0.0f, -5.0f );
			glColor3f ( 0.5f, 0.5f, 0.5f ); glVertex3f ( 0.0f, -getHeight(), -5.0f );
			// bottom left to bottom right
			glColor3f ( 0.5f, 0.5f, 0.5f ); glVertex3f ( 0.0f, -getHeight(), -5.0f );
			glColor3f ( 0.5f, 0.5f, 0.5f ); glVertex3f ( getWidth(), -getHeight(), -5.0f );
			// bottom right to top right
			glColor3f ( 0.5f, 0.5f, 0.5f ); glVertex3f ( getWidth(), -getHeight(), -5.0f );
			glColor3f ( 0.5f, 0.5f, 0.5f ); glVertex3f ( getWidth(), 0, -5.0f );
			glEnd();

			// and some points.
			glColor3f ( 1.0f, 1.0f, 1.0f );
			// note, pt size this is 'driver' dependent, this might not work
			// under windows or something. I've read that in the OGL SuperBible.
			glPointSize ( 4.125f );
			glBegin ( GL_POINTS );
			glVertex3f ( 0.0f, 0.0f, -0.0f );
			glVertex3f ( getWidth(), 0.0f, -0.0f );
			glVertex3f ( 0.0f, -getHeight(), -0.0f );
			glVertex3f ( getWidth(), -getHeight(), -0.0f );
			glEnd();

			// also, draw the bounding boxes here for debugging.

			if ( m_boundingBox != NULL )
			{
				glBegin ( GL_POINTS );
				glVertex3f ( m_boundingBox->m_x1, m_boundingBox->m_y1, 0.0f );
				glVertex3f ( m_boundingBox->m_x2, m_boundingBox->m_y2, 0.0f );
				glEnd();
			}
		}
#endif
	}
} // namespace gp2d
